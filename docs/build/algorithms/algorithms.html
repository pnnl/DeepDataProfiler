<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>algorithms package &mdash; Deep Data Profiler 1.2.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/copybutton.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Installing Deep Data Profiler" href="../install.html" />
    <link rel="prev" title="algorithms" href="modules.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Deep Data Profiler
            <img src="../_static/Profilingicon.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../overview/index.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../classes/modules.html">Profiling</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">Algorithms</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">algorithms package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-algorithms.homology">algorithms.homology module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-algorithms.jaccard">algorithms.jaccard module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-algorithms.spectral_analysis">algorithms.spectral_analysis module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-algorithms">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installing Deep Data Profiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tableofcontents.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Deep Data Profiler</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="modules.html">algorithms</a> &raquo;</li>
      <li>algorithms package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/algorithms/algorithms.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="algorithms-package">
<h1>algorithms package<a class="headerlink" href="#algorithms-package" title="Permalink to this headline"></a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline"></a></h2>
</section>
<section id="module-algorithms.homology">
<span id="algorithms-homology-module"></span><h2>algorithms.homology module<a class="headerlink" href="#module-algorithms.homology" title="Permalink to this headline"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="algorithms.homology.graph_from_tuples">
<span class="sig-prename descclassname"><span class="pre">algorithms.homology.</span></span><span class="sig-name descname"><span class="pre">graph_from_tuples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tuples:</span> <span class="pre">typing.List[typing.Tuple[typing.Tuple[int,</span> <span class="pre">typing.Union[typing.Tuple[int],</span> <span class="pre">typing.Tuple[int,</span> <span class="pre">int]]],</span> <span class="pre">typing.Tuple[int,</span> <span class="pre">typing.Union[typing.Tuple[int],</span> <span class="pre">typing.Tuple[int,</span> <span class="pre">int]]],</span> <span class="pre">float]],</span> <span class="pre">directed:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True,</span> <span class="pre">weight_func:</span> <span class="pre">typing.Callable[[float],</span> <span class="pre">float]</span> <span class="pre">=</span> <span class="pre">&lt;function</span> <span class="pre">&lt;lambda&gt;&gt;</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">networkx.classes.graph.Graph</span></span></span><a class="reference internal" href="../_modules/algorithms/homology.html#graph_from_tuples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#algorithms.homology.graph_from_tuples" title="Permalink to this definition"></a></dt>
<dd><p>Returns a weighted graph constructed from a set of tuples</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tuples</strong> (<em>iterable</em>) – An iterable of tuples of the form (vertex1, vertex2, weight)</p></li>
<li><p><strong>weight_func</strong> (<em>function</em>) – A function that takes the weight from a tuple as its input
and returns the weight of the edge between vertex1 and vertex2 in the graph,
default= f(x)=x</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – A weighted graph with edge weights given by the weight_func of the tuple weights</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>networkx.Graph</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="algorithms.homology.mat_from_graph">
<span class="sig-prename descclassname"><span class="pre">algorithms.homology.</span></span><span class="sig-name descname"><span class="pre">mat_from_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G:</span> <span class="pre">networkx.classes.graph.Graph,</span> <span class="pre">kernel:</span> <span class="pre">typing.Callable[[float],</span> <span class="pre">float]</span> <span class="pre">=</span> <span class="pre">&lt;function</span> <span class="pre">&lt;lambda&gt;&gt;</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="reference internal" href="../_modules/algorithms/homology.html#mat_from_graph"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#algorithms.homology.mat_from_graph" title="Permalink to this definition"></a></dt>
<dd><p>Given a weighted graph create a matrix based on a kernel function of the shortest weighted path distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkx.Graph</em>) – A weighted graph</p></li>
<li><p><strong>kernel</strong> (<em>function</em>) – A function of the shortest weighted path distance, default= f(x)=x</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>matrix</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This will only be a distance matrix if the kernel function keeps things as distances.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="algorithms.homology.ripser_of_distmat">
<span class="sig-prename descclassname"><span class="pre">algorithms.homology.</span></span><span class="sig-name descname"><span class="pre">ripser_of_distmat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dist_matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxdim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="reference internal" href="../_modules/algorithms/homology.html#ripser_of_distmat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#algorithms.homology.ripser_of_distmat" title="Permalink to this definition"></a></dt>
<dd><p>Given a distance matrix compute the persistent homology using ripser.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dist_matrix</strong> (<em>numpy.ndarray</em>) – A distance matrix</p></li>
<li><p><strong>maxdim</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – The maximum homology dimension to compute, default=1</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>R</strong> – A dictionary holding the results of the computation</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The given dist_mat should be a distance matrix, but this is not strictly enforced</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="algorithms.homology.ripser_of_graph">
<span class="sig-prename descclassname"><span class="pre">algorithms.homology.</span></span><span class="sig-name descname"><span class="pre">ripser_of_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G:</span> <span class="pre">networkx.classes.graph.Graph,</span> <span class="pre">kernel:</span> <span class="pre">typing.Callable[[float],</span> <span class="pre">float]</span> <span class="pre">=</span> <span class="pre">&lt;function</span> <span class="pre">&lt;lambda&gt;&gt;,</span> <span class="pre">maxdim:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">1</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="reference internal" href="../_modules/algorithms/homology.html#ripser_of_graph"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#algorithms.homology.ripser_of_graph" title="Permalink to this definition"></a></dt>
<dd><p>Given a weighted graph compute the persistent homology using ripser.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkx.Graph</em>) – A weighted graph</p></li>
<li><p><strong>kernel</strong> (<em>function</em>) – A function of the shortest weighted path distance, default= f(x)=x</p></li>
<li><p><strong>maxdim</strong> (<em>int</em>) – The maximum homology dimension to compute, default=1</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>R</strong> – A dictionary holding the results of the computation</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The given kernel function should produce a distance matrix, but this is not strictly enforced</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="algorithms.homology.tuples_from_dict">
<span class="sig-prename descclassname"><span class="pre">algorithms.homology.</span></span><span class="sig-name descname"><span class="pre">tuples_from_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layers</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/algorithms/homology.html#tuples_from_dict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#algorithms.homology.tuples_from_dict" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of tuples representing synapses up to a specified layer</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<em>dict</em>) – A dictionary of synapse weights, keyed by layer and synapse</p></li>
<li><p><strong>layers</strong> (<em>list</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – If None (default), dictionary entries for all layers will be included in the list of tuples,
otherwise, entries from the layers given in the list will be included</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tuples</strong> – A list of tuples of the form ((layer1, (neuron1,)), (layer2, (neuron2,)), weight)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Neurons are renamed to be (layer, neuron) since different layers may have the same neuron indices.
The parameter nlayers is an inclusive bound.</p>
</div>
</dd></dl>

</section>
<section id="module-algorithms.jaccard">
<span id="algorithms-jaccard-module"></span><h2>algorithms.jaccard module<a class="headerlink" href="#module-algorithms.jaccard" title="Permalink to this headline"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="algorithms.jaccard.avg_jaccard">
<span class="sig-prename descclassname"><span class="pre">algorithms.jaccard.</span></span><span class="sig-name descname"><span class="pre">avg_jaccard</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">profile1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">deep_data_profiler.classes.profile.Profile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">profile2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">deep_data_profiler.classes.profile.Profile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neuron</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layers</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="../_modules/algorithms/jaccard.html#avg_jaccard"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#algorithms.jaccard.avg_jaccard" title="Permalink to this definition"></a></dt>
<dd><p>Computes the jaccard similarity at each layer using synapse sets (or
neuron sets) then averages the values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>profile1</strong> (<a class="reference internal" href="../classes/classes.html#classes.profile.Profile" title="classes.profile.Profile"><em>Profile</em></a>) – </p></li>
<li><p><strong>profile2</strong> (<a class="reference internal" href="../classes/classes.html#classes.profile.Profile" title="classes.profile.Profile"><em>Profile</em></a>) – </p></li>
<li><p><strong>neuron</strong> (<em>bool</em><em>, </em><em>optional</em><em>, </em><em>default=False</em>) – Set to true if wish to compute the iou on the neuron sets instead
of the synapse sets</p></li>
<li><p><strong>layers</strong> (<em>list</em><em>, </em><em>optional</em><em>, </em><em>deafult=None</em>) – Specify a list of layers to calculate similarity over, defaults
to all layers of the profile</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Mean Intersection-over-Union (IOU) across layers of synapse (neuron) sets
in Profile object.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#algorithms.jaccard.jaccard_simple" title="algorithms.jaccard.jaccard_simple"><code class="xref py py-obj docutils literal notranslate"><span class="pre">jaccard_simple</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="algorithms.jaccard.instance_jaccard">
<span class="sig-prename descclassname"><span class="pre">algorithms.jaccard.</span></span><span class="sig-name descname"><span class="pre">instance_jaccard</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">profile1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">deep_data_profiler.classes.profile.Profile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">profile2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">deep_data_profiler.classes.profile.Profile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neuron</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="../_modules/algorithms/jaccard.html#instance_jaccard"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#algorithms.jaccard.instance_jaccard" title="Permalink to this definition"></a></dt>
<dd><p>Computes the proportion of synapses(or neurons/neurons) of profile1 that
belongs to profile2 synapses(or neurons/neurons)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>profile1</strong> (<a class="reference internal" href="../classes/classes.html#classes.profile.Profile" title="classes.profile.Profile"><em>Profile</em></a>) – Typically a single image profile</p></li>
<li><p><strong>profile2</strong> (<a class="reference internal" href="../classes/classes.html#classes.profile.Profile" title="classes.profile.Profile"><em>Profile</em></a>) – Typically an aggregated profile of many images</p></li>
<li><p><strong>neuron</strong> (<em>bool</em>) – <dl class="simple">
<dt>Set to True if wish to compute proportions in terms of neurons instead</dt><dd><p>of synapses</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The proportion of profile1 in profile2.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="algorithms.jaccard.jaccard">
<span class="sig-prename descclassname"><span class="pre">algorithms.jaccard.</span></span><span class="sig-name descname"><span class="pre">jaccard</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">profile1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">deep_data_profiler.classes.profile.Profile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">profile2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">deep_data_profiler.classes.profile.Profile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neuron</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layers</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="../_modules/algorithms/jaccard.html#jaccard"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#algorithms.jaccard.jaccard" title="Permalink to this definition"></a></dt>
<dd><p>Computes the jaccard similarity metric between two profiles using
the aggregation of all synapse sets (or neuron set across all layers</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>profile1</strong> (<a class="reference internal" href="../classes/classes.html#classes.profile.Profile" title="classes.profile.Profile"><em>Profile</em></a>) – </p></li>
<li><p><strong>profile2</strong> (<a class="reference internal" href="../classes/classes.html#classes.profile.Profile" title="classes.profile.Profile"><em>Profile</em></a>) – </p></li>
<li><p><strong>neuron</strong> (<em>bool</em><em>, </em><em>optional</em><em>, </em><em>default=False</em>) – Set to true if wish to compute the jaccard on the neuron sets instead
of the synapse sets</p></li>
<li><p><strong>layers</strong> (<em>list</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Specify a list of layers to calculate similarity over, defaults
to all layers of the profile</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#algorithms.jaccard.jaccard_simple" title="algorithms.jaccard.jaccard_simple"><code class="xref py py-obj docutils literal notranslate"><span class="pre">jaccard_simple</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="algorithms.jaccard.jaccard_simple">
<span class="sig-prename descclassname"><span class="pre">algorithms.jaccard.</span></span><span class="sig-name descname"><span class="pre">jaccard_simple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">scipy.sparse.base.spmatrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mat2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">scipy.sparse.base.spmatrix</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="../_modules/algorithms/jaccard.html#jaccard_simple"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#algorithms.jaccard.jaccard_simple" title="Permalink to this definition"></a></dt>
<dd><p>Computes the jaccard similarity of two sets = size of their
intersection / size of their union</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mat1</strong> (<em>scipy.sparse matrix</em>) – </p></li>
<li><p><strong>mat2</strong> (<em>scipy.sparse matrix</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-algorithms.spectral_analysis">
<span id="algorithms-spectral-analysis-module"></span><h2>algorithms.spectral_analysis module<a class="headerlink" href="#module-algorithms.spectral_analysis" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="algorithms.spectral_analysis.SpectralAnalysis">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">algorithms.spectral_analysis.</span></span><span class="sig-name descname"><span class="pre">SpectralAnalysis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">torch.nn.modules.module.Module</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/algorithms/spectral_analysis.html#SpectralAnalysis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#algorithms.spectral_analysis.SpectralAnalysis" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Spectral Analysis is based on methods originating from Random Matrix theory,
brought to deep neural networks by Martin and Mahoney.  <a class="reference external" href="https://arxiv.org/abs/1901.08276/">Traditional and Heavy-Tailed Self Regularization in Neural Network Models</a> by Martin and Mahoney
<a class="reference external" href="https://arxiv.org/abs/2002.06716/">Predicting trends in the quality of state-of-the-art neural networks without access to training or testing data</a> by Martin, Peng,and Mahoney</p>
<p>These methods act only on the weights of the Fully Connected and
Convolutional layers a deep neural network. Despite this, they have
proven effective in predicting
1. Test accuracies with no access to the data distribution on which it was trained OR tested
2. Relative performance between models of similar architecture classes
3. Model and architecture improvements while training</p>
<p>The major improvement we make over the above work is our handling of
convolutional layers: our methods are more principled, and over an
order of magnitude faster than the code released by the authors in
<a class="reference external" href="https://github.com/CalculatedContent/WeightWatcher">https://github.com/CalculatedContent/WeightWatcher</a>.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="algorithms.spectral_analysis.SpectralAnalysis.implemented_classes">
<span class="sig-name descname"><span class="pre">implemented_classes</span></span><a class="headerlink" href="#algorithms.spectral_analysis.SpectralAnalysis.implemented_classes" title="Permalink to this definition"></a></dt>
<dd><p>List of classes in PyTorch we can examine,
i.e. have implemented spectral distributions</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>set</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="algorithms.spectral_analysis.SpectralAnalysis.model">
<span class="sig-name descname"><span class="pre">model</span></span><a class="headerlink" href="#algorithms.spectral_analysis.SpectralAnalysis.model" title="Permalink to this definition"></a></dt>
<dd><p>model to be spectral-analyzed</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>torch.nn.Module()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="algorithms.spectral_analysis.SpectralAnalysis.fit_power_law">
<span class="sig-name descname"><span class="pre">fit_power_law</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eig_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_alpha</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_eig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/algorithms/spectral_analysis.html#SpectralAnalysis.fit_power_law"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#algorithms.spectral_analysis.SpectralAnalysis.fit_power_law" title="Permalink to this definition"></a></dt>
<dd><p>Fits the eigenvalue spectrum distribution of
the layer weights <span class="math notranslate nohighlight">\(X = W W^T\)</span> with a power-law distribution.
Uses the MLE approach from <a class="reference external" href="https://arxiv.org/abs/0706.1062">https://arxiv.org/abs/0706.1062</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eigdict</strong> (<em>Dict</em><em>[</em><em>int</em><em>, </em><em>Tuple</em><em>[</em><em>np.array</em><em>, </em><em>float</em><em>]</em><em>]</em>) – Optional, useful if pre-computed with <cite>.spectral_analysisr()</cite>
Dictionary with keys of the nth layer proviled,
values of <code class="xref py py-attr docutils literal notranslate"><span class="pre">(eigenvalues,</span> <span class="pre">Q)</span></code>, where <code class="xref py py-attr docutils literal notranslate"><span class="pre">eigenvalues</span></code>
are those of the weight matrix for the layer, and <code class="xref py py-attr docutils literal notranslate"><span class="pre">Q</span></code>
is the aspect ratio of the matrix.</p></li>
<li><p><strong>plot_alpha</strong> (<em>bool</em>) – Plot per-layer power-law fit of the
eigenvalue spectrum distribution.</p></li>
<li><p><strong>plot_eig</strong> (<em>bool</em>) – Plot per-layer eigenvalue spectrum distribution</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>alpha_dict</strong> – Dictionary with keys of the nth layer proviled,
values of <cite>(alpha, eig_max)</cite>, where <cite>alpha</cite>
is the power law fit alpha, i.e:
:math: rho(lambda) sim lambda^{-alpha}.
<cite>eig_max</cite> is the max eigenvalue.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Dict[int, Tuple[float, float]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="algorithms.spectral_analysis.SpectralAnalysis.layer_RMT">
<span class="sig-name descname"><span class="pre">layer_RMT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_alpha</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_eig</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Dict</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/algorithms/spectral_analysis.html#SpectralAnalysis.layer_RMT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#algorithms.spectral_analysis.SpectralAnalysis.layer_RMT" title="Permalink to this definition"></a></dt>
<dd><p>Prints the random matrix theory phenomenology of
the layer eigenspectrum distribution from <span class="math notranslate nohighlight">\(X = W W^T\)</span>.
From <a class="reference external" href="https://arxiv.org/abs/1901.08276">https://arxiv.org/abs/1901.08276</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alpha_dict</strong> (<em>Dict</em><em>[</em><em>int</em><em>, </em><em>Tuple</em><em>[</em><em>float</em><em>, </em><em>float</em><em>]</em><em>]</em>) – Optional, useful if pre-computed with <cite>.spectral_analysisr()</cite>
Dictionary with keys of the nth layer proviled,
values of <cite>(alpha, eig_max)</cite></p></li>
<li><p><strong>plot_alpha</strong> (<em>bool</em>) – Plot per-layer power-law fit of the
eigenvalue spectrum distribution.</p></li>
<li><p><strong>plot_eig</strong> (<em>bool</em>) – Plot per-layer eigenvalue spectrum distribution</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="algorithms.spectral_analysis.SpectralAnalysis.spectral_analysis">
<span class="sig-name descname"><span class="pre">spectral_analysis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.array</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/algorithms/spectral_analysis.html#SpectralAnalysis.spectral_analysis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#algorithms.spectral_analysis.SpectralAnalysis.spectral_analysis" title="Permalink to this definition"></a></dt>
<dd><p>Returns a dictionary keyed by the order of
the linear and convolutional layers, with the
eigenvalues of <span class="math notranslate nohighlight">\(X = W W^T\)</span>.
Optional plot of the spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>plot</strong> (<em>bool</em>) – Plot per-layer empirical spectral distribution.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>eigdict</strong> – Dictionary with keys of the nth layer proviled,
values of <code class="xref py py-attr docutils literal notranslate"><span class="pre">(eigenvalues,</span> <span class="pre">Q)</span></code>, where <code class="xref py py-attr docutils literal notranslate"><span class="pre">eigenvalues</span></code>
are those of the weight matrix for the layer, and <code class="xref py py-attr docutils literal notranslate"><span class="pre">Q</span></code>
is the aspect ratio of the matrix.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Dict[int, Tuple[float, float]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="algorithms.spectral_analysis.SpectralAnalysis.universal_metric">
<span class="sig-name descname"><span class="pre">universal_metric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="../_modules/algorithms/spectral_analysis.html#SpectralAnalysis.universal_metric"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#algorithms.spectral_analysis.SpectralAnalysis.universal_metric" title="Permalink to this definition"></a></dt>
<dd><p>Returns the universal capacity metric
<span class="math notranslate nohighlight">\(\widehat{\alpha}=\frac{1}{L} \sum_{l} \alpha_{l} \log \lambda_{\max , l}\)</span> from
<a class="reference external" href="https://arxiv.org/abs/2002.06716">https://arxiv.org/abs/2002.06716</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>alpha_dict</strong> (<em>Dict</em><em>[</em><em>int</em><em>, </em><em>Tuple</em><em>[</em><em>float</em><em>, </em><em>float</em><em>]</em><em>]</em>) – Optional, useful if pre-computed with <cite>.spectral_analysisr()</cite>
Dictionary with keys of the nth layer proviled,
values of <cite>(alpha, eig_max)</cite></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>metric</strong> – Universal capacity metric. A useful engineering metric
for average case capacity in DNNs, from
<a class="reference external" href="https://arxiv.org/abs/1901.08278">https://arxiv.org/abs/1901.08278</a></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-algorithms">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-algorithms" title="Permalink to this headline"></a></h2>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="modules.html" class="btn btn-neutral float-left" title="algorithms" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../install.html" class="btn btn-neutral float-right" title="Installing Deep Data Profiler" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020 Battelle Memorial Institute.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>